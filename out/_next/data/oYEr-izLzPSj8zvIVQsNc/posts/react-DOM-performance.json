{"pageProps":{"postData":{"id":"react-DOM-performance","contentHtml":"<h2>뉴스룸 페이지 (수정전)</h2>\n<p><img src=\"https://github.com/ha3158987/hyuna-next.js-blog/assets/65105537/2dda3362-3492-4243-bb9e-e30c582b2be2\" alt=\"images/newsroom-before.mov\"></p>\n<h3>1. 메인뉴스와 컨텐츠 컴포넌트 분리</h3>\n<ul>\n<li><code>MainDisplayArticle</code>컴포넌트 → <code>MainDisplayCarousel</code> &#x26; <code>NewsArticleList</code>컴포넌트로 분리</li>\n<li>메인뉴스캐로셀과 하위의 기사리스트를 분리해서 기존에 둘 중 하나가 변경되면 같이 리렌더링 되던 문제를 해결. 각각의 컴포넌트가 독립적으로 렌더링되게 함.</li>\n</ul>\n<h3>2. 하위 컴포넌트 React.memo 적용</h3>\n<blockquote>\n<p>컴포넌트가 <code>React.memo()</code>로 래핑될 때, React는 컴포넌트를 렌더링하고 결과를 메모이징(memoizing)한다. 그리고 다음 렌더링이 일어날 때 <code>props</code>가 같다면 React는 메모이징된 내용을 재사용한다.\n메모이징 한 결과를 재사용함으로써, React에서 리렌더링을 할 떄 가상 DOM에서 달라진 부분을 확인하지 않기 떄문에 성능상의 이점을 누릴 수 있다.</p>\n</blockquote>\n<ul>\n<li>Toast UI ‘<a href=\"https://ui.toast.com/weekly-pick/ko_20190731\">React.memo() 현명하게 사용하기</a>’\n<blockquote>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// 부모 컴포넌트</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MemoizedCategoryList</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'pages/NewsRoom/CategoryList'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MemoizedSwitchSectionBtns</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'pages/NewsRoom/SwitchSectionBtns'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">NewsArticleList</span> = (<span class=\"hljs-params\"></span>) => {\n\t<span class=\"hljs-keyword\">return</span> (\n\t\t<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ContentContainer</span>></span>\n\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MemoizedCategoryList</span> <span class=\"hljs-attr\">selected</span>=<span class=\"hljs-string\">{category}</span> <span class=\"hljs-attr\">handleClick</span>=<span class=\"hljs-string\">{handleCategoryChange}</span> /></span>\n\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MemoizedSwitchSectionBtns</span> <span class=\"hljs-attr\">section</span>=<span class=\"hljs-string\">{section}</span> <span class=\"hljs-attr\">handleClick</span>=<span class=\"hljs-string\">{handleSectionChange}</span> /></span>\n\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ContentContainer</span>></span></span>\n\t)\n}\n\n-----------------------------------------------------------------------------\n<span class=\"hljs-comment\">// 자식 컴포넌트</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">CategoryList</span> = (<span class=\"hljs-params\"></span>) => {\n\t<span class=\"hljs-keyword\">return</span> (<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>...생략<span class=\"hljs-tag\">&#x3C;/></span></span>)\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MemoizedCategoryList</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">memo</span>(<span class=\"hljs-title class_\">CategoryList</span>);\n</code></pre>\n<h3>3. handle함수 useCallback 적용</h3>\n<ul>\n<li>자식 컴포넌트인 <code>MemoizedCategoryList</code> 와 <code>MemoizedSwitchSectionBtns</code> 는 메모이징을 위해 React.memo()로 감싸진 컴포넌트들.</li>\n<li>그렇지만 props로 전달되는 handle 함수(handleCategoryChange, handleSectionChange)를 useCallback으로 감싸지 않으면 매번 handle 함수가 새롭게 정의되므로 <code>MemoizedCategoryList</code> 와 <code>MemoizedSwitchSectionBtns</code>는 여전히 리렌더링 된다.</li>\n<li>메모이징 된 컴포넌트에 전달되는 콜백함수까지 useCallback으로 감싸야만 진정한 리렌더링 방지가 가능!</li>\n</ul>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// 부모 컴포넌트</span>\n<span class=\"hljs-keyword\">import</span> { useState, useCallback } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">const</span> handleCategoryChange = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">id: <span class=\"hljs-built_in\">number</span></span>) =></span> {\n    <span class=\"hljs-title function_\">setCategory</span>(id);\n  }, []);\n\n<span class=\"hljs-keyword\">const</span> handleSectionChange = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">section: <span class=\"hljs-string\">'latest'</span> | <span class=\"hljs-string\">'popularity'</span></span>) =></span> {\n    <span class=\"hljs-title function_\">setSection</span>(section);\n  }, []);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">NewsArticleList</span> = (<span class=\"hljs-params\"></span>) => {\n\t<span class=\"hljs-keyword\">return</span> (\n\t\t<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ContentContainer</span>></span>\n\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MemoizedCategoryList</span> <span class=\"hljs-attr\">selected</span>=<span class=\"hljs-string\">{category}</span> <span class=\"hljs-attr\">handleClick</span>=<span class=\"hljs-string\">{handleCategoryChange}</span> /></span>\n\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MemoizedSwitchSectionBtns</span> <span class=\"hljs-attr\">section</span>=<span class=\"hljs-string\">{section}</span> <span class=\"hljs-attr\">handleClick</span>=<span class=\"hljs-string\">{handleSectionChange}</span> /></span>\n\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ContentContainer</span>></span></span>\n\t)\n}\n\n---------------------------------------------------------------------------\n<span class=\"hljs-comment\">// 자식 컴포넌트에서</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MemoizedCategoryList</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">memo</span>(<span class=\"hljs-title class_\">CategoryList</span>);\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MemoizedSwitchSectionBtns</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">memo</span>(<span class=\"hljs-title class_\">SwitchSectionBtns</span>);\n</code></pre>\n<h3>4. React.lazy및 Suspense 적용 (코드 스플리팅과 지연로딩)</h3>\n<blockquote>\n<p>사용하지 않는 소스코드를 전부 한번에 불러오면 번들 파일의 크기가 커지기 때문에 화면 로딩 시간이 길어져 사용자 경험을 저해한다.\n실제 로드될 화면에 필요한 번들 파일만 불러오고 나머지 번들 파일은 호출하지 않고 지연시킴으로써 더 빠른 속도로 화면이 보여지게 된다.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://jforj.tistory.com/162\">[React] 코드 스플리팅으로 최적화하기</a>\n<blockquote>\n</blockquote>\n</li>\n<li><code>React.lazy()</code> 를 이용한 dynamic import</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Router.tsx</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, {<span class=\"hljs-title class_\">Suspense</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MainPage</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">()=></span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">'./MainPage'</span>))\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ViewPage</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">()=></span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">'./ViewPage'</span>))\n\n&#x3C;<span class=\"hljs-title class_\">Suspense</span> fallback={<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>}>\n\t<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Routes</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Route</span> <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">'/'</span> <span class=\"hljs-attr\">element</span>=<span class=\"hljs-string\">{MainPage}</span> /></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Route</span> <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">'/view'</span> <span class=\"hljs-attr\">element</span>=<span class=\"hljs-string\">{ViewPage}</span> /></span>\n\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Routes</span>></span></span>\n&#x3C;/<span class=\"hljs-title class_\">Suspense</span>>\n</code></pre>\n<ul>\n<li><code>Suspense</code> 를 이용한 결합 시 로딩 상태 처리</li>\n</ul>\n<blockquote>\n<p>네트워크를 통해 컴포넌트 내부의 분할 구성 요소를 가져올때면 사용자는 항상 약간의 지연을 경험하게 된다. 따라서 로딩 상태를 표시하는 것이 중요하다. Suspense를 이용하면 모든 구성 요소가 로딩될 때까지 <code>fallback</code>으로 설정된 로딩상태를 보여준다.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://web.dev/i18n/ko/code-splitting-suspense/\">React.lazy 및 Suspense를 사용한 코드 분할</a>\n<blockquote>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// NewsRoomPage</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { <span class=\"hljs-title class_\">Suspense</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">NewsArticleList</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =></span>\n  <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">\"pages/NewsRoom/NewsArticleList\"</span>)\n);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MainDisplayCarousel</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =></span>\n  <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">\"pages/NewsRoom/MainDisplayCarousel\"</span>)\n);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">NewsRoomPage</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">div</span>></span>로딩중입니다...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>}>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Title</span>></span>뉴스룸<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Title</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MainDisplayCarousel</span> /></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">NewsArticleList</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Suspense</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n}\n</code></pre>\n<h3>5. 캐로셀 방식으로 리렌더링 최소화 (pre-rendering)</h3>\n<p><img src=\"https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F211bd81f-0e8d-45ae-b88e-0c94980c5a3f%2FUntitled.png?table=block&#x26;id=d0b5d7e9-79ac-40e7-afc4-080f329fddca&#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43&#x26;width=2000&#x26;userId=&#x26;cache=v2\" alt=\"image Untitled\"></p>\n<ul>\n<li>기존에 <code>slice</code>와 <code>map</code>으로 화살표 클릭시 보여지는 4개의 속보 리스트를 매번 새롭게 그려주던 방식에서 미리 모든 리스트를 렌더링하고 노출되는 부분을 <code>transform: translateX(__px)</code>로 이동시키는 방식으로 변경. 페이지 초기 렌더링 시간은 살짝 증가했지만, 불필요한 리렌더링을 최소화해서 DOM 최적화를 도모.</li>\n</ul>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translateX</span>(${(props) => props<span class=\"hljs-selector-class\">.xAxis</span>}px);\n</code></pre>\n<hr>\n<h2>결과</h2>\n<ul>\n<li>BEFORE\n<img src=\"https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb7ebe963-a4a1-4f54-9277-c41f462591ec%2FUntitled.png?table=block&#x26;id=7cd47ac7-4022-43e6-8fe3-734b10068791&#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43&#x26;width=2000&#x26;userId=&#x26;cache=v2\" alt=\"image before-screenshot\"></li>\n<li>AFTER\n<img src=\"https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Feb3a7112-4364-4e14-a1ce-9102e0beb1cc%2FUntitled.png?table=block&#x26;id=19159d7e-4664-4a2a-93c8-eb5977585534&#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43&#x26;width=2000&#x26;userId=&#x26;cache=v2\" alt=\"image after-screenshot\"></li>\n</ul>\n<h3>Performance: 35 → 58</h3>\n<ul>\n<li>First Contentful Paint(첫 컨텐츠의 첫 픽셀이 그려지는 시간): 4.3s → 0.6s</li>\n<li>Speed Index(브라우저의 시각적 완료 단계를 정량적으로 계산): 4.3s → 1.6s</li>\n<li>Largest Contentful Paint(주요 컨텐츠를 볼 수 있는 시점): 6.6s → 4.4s</li>\n<li>Time to Interactive(사용자와의 상호작용이 가능해지는 시간): 5.8s → 3.8s</li>\n<li>Total Blocking Time(총 차단시간: First Contentful Paint 와 Time to Interactive 사이): 70ms → 0ms</li>\n<li>Cumulative Layout Shift(사용자가 예상치 못한 레이아웃 이동을 경험하는 빈도): 0.773s → 0.835s\n<ul>\n<li>이미지 요소에 크기 속성을 미리 확보하지 않은 점과 캐로셀로 좀 더 많은 이미지를 더 그려야 하는 점때문인 것으로 추측… CLS 개선방법</li>\n</ul>\n</li>\n</ul>\n","title":"Lighthouse로 측정한 React DOM 최적화","date":"2022-08-22"}},"__N_SSG":true}