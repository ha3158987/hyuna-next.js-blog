<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/hyuna-next.js-blog/images/profile.jpg"/><meta name="description" content="Learn how to build a personal website using Next.js"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Sample%20Website.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Next.js Sample Website"/><meta name="twitter:card" content="summary_large_image"/><link rel="preload" as="image" href="/hyuna-next.js-blog/images/profile.jpg"/><title>Lighthouse로 측정한 React DOM 최적화</title><meta name="next-head-count" content="9"/><link rel="preload" href="/hyuna-next.js-blog/_next/static/css/afa298ff2984d298.css" as="style"/><link rel="stylesheet" href="/hyuna-next.js-blog/_next/static/css/afa298ff2984d298.css" data-n-g=""/><link rel="preload" href="/hyuna-next.js-blog/_next/static/css/9fe1b9c5999b994c.css" as="style"/><link rel="stylesheet" href="/hyuna-next.js-blog/_next/static/css/9fe1b9c5999b994c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/hyuna-next.js-blog/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/hyuna-next.js-blog/_next/static/chunks/webpack-2f8107d94cbfe67f.js" defer=""></script><script src="/hyuna-next.js-blog/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/hyuna-next.js-blog/_next/static/chunks/main-11afd4c86402b25f.js" defer=""></script><script src="/hyuna-next.js-blog/_next/static/chunks/pages/_app-84851d000d10e396.js" defer=""></script><script src="/hyuna-next.js-blog/_next/static/chunks/562-de79e1b556b6e6bf.js" defer=""></script><script src="/hyuna-next.js-blog/_next/static/chunks/pages/posts/%5Bid%5D-4687a418a6f5cfe9.js" defer=""></script><script src="/hyuna-next.js-blog/_next/static/eK6IAmDeKEZn1ZXQvuilu/_buildManifest.js" defer=""></script><script src="/hyuna-next.js-blog/_next/static/eK6IAmDeKEZn1ZXQvuilu/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><header class="layout_header__kY0Lt"><a href="/hyuna-next.js-blog"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27108%27%20height=%27108%27/%3e"/></span><img alt="Dico" src="/hyuna-next.js-blog/images/profile.jpg" decoding="async" data-nimg="intrinsic" class="utils_borderCircle__s2nTm" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/></span></a><h2 class="utils_headingLg__5535D"><a class="utils_colorInherit__mSH_x" href="/hyuna-next.js-blog">Dico</a></h2></header><main><article><h1 class="utils_headingXl__u25Y2">Lighthouse로 측정한 React DOM 최적화</h1><div class="utils_lightText__eUzGY"><time dateTime="2022-08-22">August 22, 2022</time></div><div><h2>뉴스룸 페이지</h2>
<h3>수정 전</h3>
<ul>
<li>불필요한 리렌더링이 많이 일어나는 상태. 버튼 하나만 눌러도 전체 페이지가 전부 리렌더링 된다.
<img src="https://github.com/ha3158987/hyuna-next.js-blog/assets/65105537/2dda3362-3492-4243-bb9e-e30c582b2be2" alt="images/newsroom-before.mov"></li>
</ul>
<h3>1. 메인뉴스와 컨텐츠 컴포넌트 분리</h3>
<ul>
<li><code>MainDisplayArticle</code>컴포넌트 → <code>MainDisplayCarousel</code> &#x26; <code>NewsArticleList</code>컴포넌트로 분리</li>
<li>메인뉴스캐로셀과 하위의 기사리스트를 분리해서 기존에 둘 중 하나가 변경되면 같이 리렌더링 되던 문제를 해결. 각각의 컴포넌트가 독립적으로 렌더링되게 함.</li>
</ul>
<h3>2. 하위 컴포넌트 React.memo 적용</h3>
<blockquote>
<p>컴포넌트가 <code>React.memo()</code>로 래핑될 때, React는 컴포넌트를 렌더링하고 결과를 메모이징(memoizing)한다. 그리고 다음 렌더링이 일어날 때 <code>props</code>가 같다면 React는 메모이징된 내용을 재사용한다.
메모이징 한 결과를 재사용함으로써, React에서 리렌더링을 할 떄 가상 DOM에서 달라진 부분을 확인하지 않기 떄문에 성능상의 이점을 누릴 수 있다.</p>
</blockquote>
<ul>
<li>Toast UI ‘<a href="https://ui.toast.com/weekly-pick/ko_20190731">React.memo() 현명하게 사용하기</a>’
<blockquote>
</blockquote>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 부모 컴포넌트</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoizedCategoryList</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'pages/NewsRoom/CategoryList'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoizedSwitchSectionBtns</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'pages/NewsRoom/SwitchSectionBtns'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">NewsArticleList</span> = (<span class="hljs-params"></span>) => {
	<span class="hljs-keyword">return</span> (
		<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ContentContainer</span>></span>
			<span class="hljs-tag">&#x3C;<span class="hljs-name">MemoizedCategoryList</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">{category}</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">{handleCategoryChange}</span> /></span>
			<span class="hljs-tag">&#x3C;<span class="hljs-name">MemoizedSwitchSectionBtns</span> <span class="hljs-attr">section</span>=<span class="hljs-string">{section}</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">{handleSectionChange}</span> /></span>
		<span class="hljs-tag">&#x3C;/<span class="hljs-name">ContentContainer</span>></span></span>
	)
}

-----------------------------------------------------------------------------
<span class="hljs-comment">// 자식 컴포넌트</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">CategoryList</span> = (<span class="hljs-params"></span>) => {
	<span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&#x3C;></span>...생략<span class="hljs-tag">&#x3C;/></span></span>)
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoizedCategoryList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">CategoryList</span>);
</code></pre>
<h3>3. handle함수 useCallback 적용</h3>
<ul>
<li>자식 컴포넌트인 <code>MemoizedCategoryList</code> 와 <code>MemoizedSwitchSectionBtns</code> 는 메모이징을 위해 React.memo()로 감싸진 컴포넌트들.</li>
<li>그렇지만 props로 전달되는 handle 함수(handleCategoryChange, handleSectionChange)를 useCallback으로 감싸지 않으면 매번 handle 함수가 새롭게 정의되므로 <code>MemoizedCategoryList</code> 와 <code>MemoizedSwitchSectionBtns</code>는 여전히 리렌더링 된다.</li>
<li>메모이징 된 컴포넌트에 전달되는 콜백함수까지 useCallback으로 감싸야만 진정한 리렌더링 방지가 가능!</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 부모 컴포넌트</span>
<span class="hljs-keyword">import</span> { useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> handleCategoryChange = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) =></span> {
    <span class="hljs-title function_">setCategory</span>(id);
  }, []);

<span class="hljs-keyword">const</span> handleSectionChange = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">section: <span class="hljs-string">'latest'</span> | <span class="hljs-string">'popularity'</span></span>) =></span> {
    <span class="hljs-title function_">setSection</span>(section);
  }, []);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">NewsArticleList</span> = (<span class="hljs-params"></span>) => {
	<span class="hljs-keyword">return</span> (
		<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ContentContainer</span>></span>
			<span class="hljs-tag">&#x3C;<span class="hljs-name">MemoizedCategoryList</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">{category}</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">{handleCategoryChange}</span> /></span>
			<span class="hljs-tag">&#x3C;<span class="hljs-name">MemoizedSwitchSectionBtns</span> <span class="hljs-attr">section</span>=<span class="hljs-string">{section}</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">{handleSectionChange}</span> /></span>
		<span class="hljs-tag">&#x3C;/<span class="hljs-name">ContentContainer</span>></span></span>
	)
}

---------------------------------------------------------------------------
<span class="hljs-comment">// 자식 컴포넌트에서</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoizedCategoryList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">CategoryList</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoizedSwitchSectionBtns</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">SwitchSectionBtns</span>);
</code></pre>
<h3>4. React.lazy및 Suspense 적용 (코드 스플리팅과 지연로딩)</h3>
<blockquote>
<p>사용하지 않는 소스코드를 전부 한번에 불러오면 번들 파일의 크기가 커지기 때문에 화면 로딩 시간이 길어져 사용자 경험을 저해한다.
실제 로드될 화면에 필요한 번들 파일만 불러오고 나머지 번들 파일은 호출하지 않고 지연시킴으로써 더 빠른 속도로 화면이 보여지게 된다.</p>
</blockquote>
<ul>
<li><a href="https://jforj.tistory.com/162">[React] 코드 스플리팅으로 최적화하기</a>
<blockquote>
</blockquote>
</li>
<li><code>React.lazy()</code> 를 이용한 dynamic import</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Router.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, {<span class="hljs-title class_">Suspense</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MainPage</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">()=></span> <span class="hljs-title function_">import</span>(<span class="hljs-string">'./MainPage'</span>))
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ViewPage</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">()=></span> <span class="hljs-title function_">import</span>(<span class="hljs-string">'./ViewPage'</span>))

&#x3C;<span class="hljs-title class_">Suspense</span> fallback={<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>}>
	<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Routes</span>></span>
		<span class="hljs-tag">&#x3C;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">'/'</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{MainPage}</span> /></span>
		<span class="hljs-tag">&#x3C;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">'/view'</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{ViewPage}</span> /></span>
	<span class="hljs-tag">&#x3C;/<span class="hljs-name">Routes</span>></span></span>
&#x3C;/<span class="hljs-title class_">Suspense</span>>
</code></pre>
<ul>
<li><code>Suspense</code> 를 이용한 결합 시 로딩 상태 처리</li>
</ul>
<blockquote>
<p>네트워크를 통해 컴포넌트 내부의 분할 구성 요소를 가져올때면 사용자는 항상 약간의 지연을 경험하게 된다. 따라서 로딩 상태를 표시하는 것이 중요하다. Suspense를 이용하면 모든 구성 요소가 로딩될 때까지 <code>fallback</code>으로 설정된 로딩상태를 보여준다.</p>
</blockquote>
<ul>
<li><a href="https://web.dev/i18n/ko/code-splitting-suspense/">React.lazy 및 Suspense를 사용한 코드 분할</a>
<blockquote>
</blockquote>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// NewsRoomPage</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Suspense</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">NewsArticleList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =></span>
  <span class="hljs-title function_">import</span>(<span class="hljs-string">"pages/NewsRoom/NewsArticleList"</span>)
);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MainDisplayCarousel</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =></span>
  <span class="hljs-title function_">import</span>(<span class="hljs-string">"pages/NewsRoom/MainDisplayCarousel"</span>)
);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">NewsRoomPage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&#x3C;<span class="hljs-attr">div</span>></span>로딩중입니다...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>}>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Title</span>></span>뉴스룸<span class="hljs-tag">&#x3C;/<span class="hljs-name">Title</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">MainDisplayCarousel</span> /></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">NewsArticleList</span> /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">Suspense</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  );
}
</code></pre>
<h3>5. 캐로셀 방식으로 리렌더링 최소화 (pre-rendering)</h3>
<p><img src="https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F211bd81f-0e8d-45ae-b88e-0c94980c5a3f%2FUntitled.png?table=block&#x26;id=d0b5d7e9-79ac-40e7-afc4-080f329fddca&#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43&#x26;width=2000&#x26;userId=&#x26;cache=v2" alt="image Untitled"></p>
<ul>
<li>기존에 <code>slice</code>와 <code>map</code>으로 화살표 클릭시 보여지는 4개의 속보 리스트를 매번 새롭게 그려주던 방식에서 미리 모든 리스트를 렌더링하고 노출되는 부분을 <code>transform: translateX(__px)</code>로 이동시키는 방식으로 변경. 페이지 초기 렌더링 시간은 살짝 증가했지만, 불필요한 리렌더링을 최소화해서 DOM 최적화를 도모.</li>
</ul>
<pre><code class="hljs language-css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(${(props) => props<span class="hljs-selector-class">.xAxis</span>}px);
</code></pre>
<hr>
<h2>결과</h2>
<ul>
<li>BEFORE
<img src="https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb7ebe963-a4a1-4f54-9277-c41f462591ec%2FUntitled.png?table=block&#x26;id=7cd47ac7-4022-43e6-8fe3-734b10068791&#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43&#x26;width=2000&#x26;userId=&#x26;cache=v2" alt="image before-screenshot"></li>
<li>AFTER
<img src="https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Feb3a7112-4364-4e14-a1ce-9102e0beb1cc%2FUntitled.png?table=block&#x26;id=19159d7e-4664-4a2a-93c8-eb5977585534&#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43&#x26;width=2000&#x26;userId=&#x26;cache=v2" alt="image after-screenshot"></li>
</ul>
<h3>Performance: 35 → 58</h3>
<ul>
<li>First Contentful Paint(첫 컨텐츠의 첫 픽셀이 그려지는 시간): 4.3s → 0.6s</li>
<li>Speed Index(브라우저의 시각적 완료 단계를 정량적으로 계산): 4.3s → 1.6s</li>
<li>Largest Contentful Paint(주요 컨텐츠를 볼 수 있는 시점): 6.6s → 4.4s</li>
<li>Time to Interactive(사용자와의 상호작용이 가능해지는 시간): 5.8s → 3.8s</li>
<li>Total Blocking Time(총 차단시간: First Contentful Paint 와 Time to Interactive 사이): 70ms → 0ms</li>
<li>Cumulative Layout Shift(사용자가 예상치 못한 레이아웃 이동을 경험하는 빈도): 0.773s → 0.835s
<ul>
<li>이미지 요소에 크기 속성을 미리 확보하지 않은 점과 캐로셀로 좀 더 많은 이미지를 더 그려야 하는 점때문인 것으로 추측… CLS 개선방법</li>
</ul>
</li>
</ul>
</div></article></main><div class="layout_backToHome__9sjx_"><a class="layout_backToHomeText__i_Z46" href="/hyuna-next.js-blog">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"react-DOM-performance","contentHtml":"\u003ch2\u003e뉴스룸 페이지\u003c/h2\u003e\n\u003ch3\u003e수정 전\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e불필요한 리렌더링이 많이 일어나는 상태. 버튼 하나만 눌러도 전체 페이지가 전부 리렌더링 된다.\n\u003cimg src=\"https://github.com/ha3158987/hyuna-next.js-blog/assets/65105537/2dda3362-3492-4243-bb9e-e30c582b2be2\" alt=\"images/newsroom-before.mov\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e1. 메인뉴스와 컨텐츠 컴포넌트 분리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eMainDisplayArticle\u003c/code\u003e컴포넌트 → \u003ccode\u003eMainDisplayCarousel\u003c/code\u003e \u0026#x26; \u003ccode\u003eNewsArticleList\u003c/code\u003e컴포넌트로 분리\u003c/li\u003e\n\u003cli\u003e메인뉴스캐로셀과 하위의 기사리스트를 분리해서 기존에 둘 중 하나가 변경되면 같이 리렌더링 되던 문제를 해결. 각각의 컴포넌트가 독립적으로 렌더링되게 함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2. 하위 컴포넌트 React.memo 적용\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e컴포넌트가 \u003ccode\u003eReact.memo()\u003c/code\u003e로 래핑될 때, React는 컴포넌트를 렌더링하고 결과를 메모이징(memoizing)한다. 그리고 다음 렌더링이 일어날 때 \u003ccode\u003eprops\u003c/code\u003e가 같다면 React는 메모이징된 내용을 재사용한다.\n메모이징 한 결과를 재사용함으로써, React에서 리렌더링을 할 떄 가상 DOM에서 달라진 부분을 확인하지 않기 떄문에 성능상의 이점을 누릴 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eToast UI ‘\u003ca href=\"https://ui.toast.com/weekly-pick/ko_20190731\"\u003eReact.memo() 현명하게 사용하기\u003c/a\u003e’\n\u003cblockquote\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 부모 컴포넌트\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMemoizedCategoryList\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'pages/NewsRoom/CategoryList'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMemoizedSwitchSectionBtns\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'pages/NewsRoom/SwitchSectionBtns'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNewsArticleList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n\t\t\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eContentContainer\u003c/span\u003e\u003e\u003c/span\u003e\n\t\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMemoizedCategoryList\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eselected\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{category}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehandleClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleCategoryChange}\u003c/span\u003e /\u003e\u003c/span\u003e\n\t\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMemoizedSwitchSectionBtns\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esection\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{section}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehandleClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleSectionChange}\u003c/span\u003e /\u003e\u003c/span\u003e\n\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eContentContainer\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\t)\n}\n\n-----------------------------------------------------------------------------\n\u003cspan class=\"hljs-comment\"\u003e// 자식 컴포넌트\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCategoryList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e...생략\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMemoizedCategoryList\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ememo\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCategoryList\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. handle함수 useCallback 적용\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e자식 컴포넌트인 \u003ccode\u003eMemoizedCategoryList\u003c/code\u003e 와 \u003ccode\u003eMemoizedSwitchSectionBtns\u003c/code\u003e 는 메모이징을 위해 React.memo()로 감싸진 컴포넌트들.\u003c/li\u003e\n\u003cli\u003e그렇지만 props로 전달되는 handle 함수(handleCategoryChange, handleSectionChange)를 useCallback으로 감싸지 않으면 매번 handle 함수가 새롭게 정의되므로 \u003ccode\u003eMemoizedCategoryList\u003c/code\u003e 와 \u003ccode\u003eMemoizedSwitchSectionBtns\u003c/code\u003e는 여전히 리렌더링 된다.\u003c/li\u003e\n\u003cli\u003e메모이징 된 컴포넌트에 전달되는 콜백함수까지 useCallback으로 감싸야만 진정한 리렌더링 방지가 가능!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 부모 컴포넌트\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState, useCallback } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handleCategoryChange = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eid: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetCategory\u003c/span\u003e(id);\n  }, []);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handleSectionChange = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003esection: \u003cspan class=\"hljs-string\"\u003e'latest'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'popularity'\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetSection\u003c/span\u003e(section);\n  }, []);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNewsArticleList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n\t\t\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eContentContainer\u003c/span\u003e\u003e\u003c/span\u003e\n\t\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMemoizedCategoryList\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eselected\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{category}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehandleClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleCategoryChange}\u003c/span\u003e /\u003e\u003c/span\u003e\n\t\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMemoizedSwitchSectionBtns\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esection\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{section}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehandleClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleSectionChange}\u003c/span\u003e /\u003e\u003c/span\u003e\n\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eContentContainer\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\t)\n}\n\n---------------------------------------------------------------------------\n\u003cspan class=\"hljs-comment\"\u003e// 자식 컴포넌트에서\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMemoizedCategoryList\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ememo\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCategoryList\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMemoizedSwitchSectionBtns\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ememo\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eSwitchSectionBtns\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4. React.lazy및 Suspense 적용 (코드 스플리팅과 지연로딩)\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e사용하지 않는 소스코드를 전부 한번에 불러오면 번들 파일의 크기가 커지기 때문에 화면 로딩 시간이 길어져 사용자 경험을 저해한다.\n실제 로드될 화면에 필요한 번들 파일만 불러오고 나머지 번들 파일은 호출하지 않고 지연시킴으로써 더 빠른 속도로 화면이 보여지게 된다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://jforj.tistory.com/162\"\u003e[React] 코드 스플리팅으로 최적화하기\u003c/a\u003e\n\u003cblockquote\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReact.lazy()\u003c/code\u003e 를 이용한 dynamic import\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Router.tsx\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, {\u003cspan class=\"hljs-title class_\"\u003eSuspense\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMainPage\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elazy\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e()=\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./MainPage'\u003c/span\u003e))\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eViewPage\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elazy\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e()=\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./ViewPage'\u003c/span\u003e))\n\n\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eSuspense\u003c/span\u003e fallback={\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eloading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e}\u003e\n\t\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRoutes\u003c/span\u003e\u003e\u003c/span\u003e\n\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRoute\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eelement\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{MainPage}\u003c/span\u003e /\u003e\u003c/span\u003e\n\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRoute\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'/view'\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eelement\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{ViewPage}\u003c/span\u003e /\u003e\u003c/span\u003e\n\t\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eRoutes\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/\u003cspan class=\"hljs-title class_\"\u003eSuspense\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSuspense\u003c/code\u003e 를 이용한 결합 시 로딩 상태 처리\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e네트워크를 통해 컴포넌트 내부의 분할 구성 요소를 가져올때면 사용자는 항상 약간의 지연을 경험하게 된다. 따라서 로딩 상태를 표시하는 것이 중요하다. Suspense를 이용하면 모든 구성 요소가 로딩될 때까지 \u003ccode\u003efallback\u003c/code\u003e으로 설정된 로딩상태를 보여준다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://web.dev/i18n/ko/code-splitting-suspense/\"\u003eReact.lazy 및 Suspense를 사용한 코드 분할\u003c/a\u003e\n\u003cblockquote\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// NewsRoomPage\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { \u003cspan class=\"hljs-title class_\"\u003eSuspense\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNewsArticleList\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elazy\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"pages/NewsRoom/NewsArticleList\"\u003c/span\u003e)\n);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMainDisplayCarousel\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elazy\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"pages/NewsRoom/MainDisplayCarousel\"\u003c/span\u003e)\n);\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNewsRoomPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efallback\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-attr\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e로딩중입니다...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e}\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTitle\u003c/span\u003e\u003e\u003c/span\u003e뉴스룸\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eTitle\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMainDisplayCarousel\u003c/span\u003e /\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eNewsArticleList\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5. 캐로셀 방식으로 리렌더링 최소화 (pre-rendering)\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F211bd81f-0e8d-45ae-b88e-0c94980c5a3f%2FUntitled.png?table=block\u0026#x26;id=d0b5d7e9-79ac-40e7-afc4-080f329fddca\u0026#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43\u0026#x26;width=2000\u0026#x26;userId=\u0026#x26;cache=v2\" alt=\"image Untitled\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기존에 \u003ccode\u003eslice\u003c/code\u003e와 \u003ccode\u003emap\u003c/code\u003e으로 화살표 클릭시 보여지는 4개의 속보 리스트를 매번 새롭게 그려주던 방식에서 미리 모든 리스트를 렌더링하고 노출되는 부분을 \u003ccode\u003etransform: translateX(__px)\u003c/code\u003e로 이동시키는 방식으로 변경. 페이지 초기 렌더링 시간은 살짝 증가했지만, 불필요한 리렌더링을 최소화해서 DOM 최적화를 도모.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-attribute\"\u003etransform\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003etranslateX\u003c/span\u003e(${(props) =\u003e props\u003cspan class=\"hljs-selector-class\"\u003e.xAxis\u003c/span\u003e}px);\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e결과\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eBEFORE\n\u003cimg src=\"https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb7ebe963-a4a1-4f54-9277-c41f462591ec%2FUntitled.png?table=block\u0026#x26;id=7cd47ac7-4022-43e6-8fe3-734b10068791\u0026#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43\u0026#x26;width=2000\u0026#x26;userId=\u0026#x26;cache=v2\" alt=\"image before-screenshot\"\u003e\u003c/li\u003e\n\u003cli\u003eAFTER\n\u003cimg src=\"https://hyunahpark.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Feb3a7112-4364-4e14-a1ce-9102e0beb1cc%2FUntitled.png?table=block\u0026#x26;id=19159d7e-4664-4a2a-93c8-eb5977585534\u0026#x26;spaceId=8a82258c-2d6f-430c-8447-c480cc77bd43\u0026#x26;width=2000\u0026#x26;userId=\u0026#x26;cache=v2\" alt=\"image after-screenshot\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ePerformance: 35 → 58\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eFirst Contentful Paint(첫 컨텐츠의 첫 픽셀이 그려지는 시간): 4.3s → 0.6s\u003c/li\u003e\n\u003cli\u003eSpeed Index(브라우저의 시각적 완료 단계를 정량적으로 계산): 4.3s → 1.6s\u003c/li\u003e\n\u003cli\u003eLargest Contentful Paint(주요 컨텐츠를 볼 수 있는 시점): 6.6s → 4.4s\u003c/li\u003e\n\u003cli\u003eTime to Interactive(사용자와의 상호작용이 가능해지는 시간): 5.8s → 3.8s\u003c/li\u003e\n\u003cli\u003eTotal Blocking Time(총 차단시간: First Contentful Paint 와 Time to Interactive 사이): 70ms → 0ms\u003c/li\u003e\n\u003cli\u003eCumulative Layout Shift(사용자가 예상치 못한 레이아웃 이동을 경험하는 빈도): 0.773s → 0.835s\n\u003cul\u003e\n\u003cli\u003e이미지 요소에 크기 속성을 미리 확보하지 않은 점과 캐로셀로 좀 더 많은 이미지를 더 그려야 하는 점때문인 것으로 추측… CLS 개선방법\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","title":"Lighthouse로 측정한 React DOM 최적화","date":"2022-08-22"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"react-DOM-performance"},"buildId":"eK6IAmDeKEZn1ZXQvuilu","assetPrefix":"/hyuna-next.js-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>